Main advantage of MongoDB compared to other relational databases: 
Sharding is a method for distributing data across multiple machines. 
MongoDB uses sharding to support deployments with very large data sets and high throughput operations.
*easy horizontal expansion through sharding


Advantage of factory pattern:
Easier to write tests for each blueprint 



Setup mongoDB:
mkdir ~/data
mkdir ~/log
rm -fr Readme.md
mkdir flaskbook
cd flaskbook
touch mongod.conf

Installing MongoDB:
sudo apt-get install -y mongodb-org

To start MongoDB:
mongod -f mongod.conf

Command line:
mongo

Connected to test database
db.test.insert({name: "Jorge", last_name: "Escobar"})  #creates document(record) inside a test collection   
 # in order to read:
 db.test.find()  #shows all
 #specific:
 db.test.find({last_name:"Sanginov"})
 
 #to create an index
 db.test.createIndex({last_name: 1})
 
 #create new record with a new attribute 
 db.test.insert({name: "Fotima", last_name: "Atabaeva", age: 20})
 #mongodb has no problem with this; other database would say no attribute age
 
 create a record(document) inside a record:
 db.test.insert({name: {first_name: "John", last_name: "Jones"}, age:23})
 
 find record with age less than 40:
 db.test.find({age: { $lt: 40} })
 #changing a record
 db.test.update({name: "Sher"}, {$set: {last_name: "Mohira"}})
 In Flask, we are going to interact with MongoDB using ORM- Object Relational Mapper
 Flask Mongo Engine.
 
 
 
 #Install virtualenv
 sudo pip install virtualenv
 
 #make python3 virtual environment
 virtualenv -p python3 env
 
 
 #Application Factories in Flask 
 It's where the modular flask app starts running
 the way we do this is to create an application instance 
 a) touch requirement.txt   (to install: pip install -r requirements.txt)
 b) write flask, mongo, library versions in there and install those requirements 
 pip install -r requirements.txt
 c)  touch settings.py #application config
 d) touch application.py  #factory file, creates an instance of Flask
 e) touch manage.py  #responsible for start stop server 
 To run the application:
 python manage.py runserver
 
 
 #Since we are building advanced scaleable modular application, we will use Flask feature called Blueprints 
 You can use it to modularize you app
 user folder (blueprint) inside view.py
 
a) inside view create user_app blueprint
b) inside application file import blueprint and register it 